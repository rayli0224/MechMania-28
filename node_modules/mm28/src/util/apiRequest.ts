import { credentials, credentialsType } from './auth.js';
import type { ApiEndpoint } from '@mm28/shared/types/api/apiTypes.js';
import { catastrophicErr, forbiddenError, unauthedError } from './messages.js';
import { StatusCodes } from 'http-status-codes';
import fetch from 'node-fetch'; // hopefully prevent that one warning about fetch being experimental

const API_SERVER_URL = 'http://api.mechmania.io';

const headers = ({name, password}: credentialsType) => ({
	'Content-Type' : 'application/json',
	...(name && password &&  {
		'Authorization': `Basic ${Buffer.from(`${name}:${password}`).toString('base64')}`
	})
});

export default async function apiRequest<T extends ApiEndpoint>(method: T['method'], route: T['route'], body: T['requestBody'] = undefined, customCredentials: credentialsType = credentials): Promise<T['response']>{
	const req = (await fetch(
		API_SERVER_URL+route, 
		{
			method,
			headers: headers(customCredentials),
			body: JSON.stringify(body)
		}
	).catch((reason) => {
		catastrophicErr(`Error during API request: ${reason}`);
	})) as Response; // TS doesn't realize that process.exit happens
	const text: string = await req.text();
	if(req.status === StatusCodes.UNAUTHORIZED) unauthedError(text);
	else if(req.status === StatusCodes.FORBIDDEN) forbiddenError(text);
	else if(!req.ok) catastrophicErr(`API request returned error w/ code ${req.status}: ${text}`);
	try {
		const parsedBody = JSON.parse(text);
		return {
			status: req.status,
			body: parsedBody
		};
	}
	catch { return catastrophicErr(`API server gave malformed response: ${text}`); }
}