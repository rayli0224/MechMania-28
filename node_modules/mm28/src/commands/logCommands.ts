import { Command } from 'commander';
import apiRequest from '../util/apiRequest.js';
import type {getTourneysEndpoint, getTourneyGamesEndpoint, getGameInfoEndpoint} from '@mm28/shared/types/api/logApiTypes.js';
import chalk from 'chalk';
import { catastrophicErr, fatalErr } from '../util/messages.js';
import inquirer, { ListChoiceOptions } from 'inquirer';
import type { DBRowTypes } from '@mm28/shared/types/dbTypes.js';
import { EntityType, RowIDTypes } from 'shared/types/dbTypes.js';
import { homedir } from 'os';
import path from 'path';
import { mkdir, writeFile } from 'fs/promises';
import fetch from 'node-fetch';

const viewTourneyCommand = new Command('leaderboard').aliases(['tournaments', 'tourneys'])
	.description('View the score of ongoing and past tournaments.')
	.action(async () => {
		const tourneyList = (await apiRequest<getTourneysEndpoint>('GET','/tourneys')).body;
		if(tourneyList.length == 0) return fatalErr('No tournaments have been run yet, check back soon...');
		const tourneyChoices : ListChoiceOptions[] = tourneyList.map((dbEntry) => ({
			name: `${(new Date(dbEntry.createdTime)).toLocaleString(undefined, {
				month: 'numeric',
				day: 'numeric',
				hour: 'numeric',
				minute: 'numeric'
			})}`,
			value: dbEntry.teams
		}));
		const board : DBRowTypes[EntityType.Tournament]['teams'] = (await inquirer.prompt([{
			type: 'list',
			loop: 'false',
			name: 'leaderboard',
			message: 'Pick a tournament to view its leaderboard:',
			choices: tourneyChoices
		}])).leaderboard;
		const rows = Object.entries(board);
		rows.sort((a,b) => (b[1].curScore - a[1].curScore));
		console.log('Team\t\tScore');
		rows.map(([team, {curScore}], idx) => {
			let row = `${team}\t\t${curScore.toLocaleString(undefined, { maximumFractionDigits: 3, minimumFractionDigits: 3 })}`;
			switch(idx){ // fun colors
				case 0:
					row = chalk.yellow(row);
					break;
				case 1:
					row = chalk.gray(row);
					break;
				case 2:
					row = chalk.bgYellow(row);
					break;
			}
			console.log(row);

		});
	});

const getGameCommand = new Command('viewgames').alias('games')
	.description('Download game logs for your viewing and debugging pleasure.')
	.action(async () => {
		const tourneyList = (await apiRequest<getTourneysEndpoint>('GET','/tourneys')).body;
		if(tourneyList.length == 0) return fatalErr('No tournaments have been run yet, check back soon...');
		const tourneyChoices : ListChoiceOptions[] = tourneyList.map((dbEntry) => ({
			name: `${(new Date(dbEntry.createdTime)).toLocaleString(undefined, {
				month: 'numeric',
				day: 'numeric',
				hour: 'numeric',
				minute: 'numeric'
			})}`,
			value: dbEntry.ID
		}));
		const tourneyID : RowIDTypes[EntityType.Tournament] = (await inquirer.prompt([{
			type: 'list',
			loop: 'false',
			name: 'val',
			message: 'Pick a tournament to view its leaderboard:',
			choices: tourneyChoices
		}])).val;
		const games = (await apiRequest<getTourneyGamesEndpoint>('GET', `/tourneys/${tourneyID.split('#')[1]}/games` as '/tourneys/:tourney/games')).body;
		const gameChoices : ListChoiceOptions[] = games.map(game => {
			const round = game.ID.split('#')[1];
			const hash = game.ID.split('#')[2].split('-')[0];
			return {
				name: `Round ${round}, game ${hash}:\t${Object.keys(game.results).join(', ')}`,
				value: game
			};
		});
		const game : DBRowTypes[EntityType.Game] = (await inquirer.prompt([{
			type: 'list',
			loop: 'false',
			name: 'val',
			message: 'Which game do you want info about?',
			choices: gameChoices
		}])).val;

		console.log('Contestants:');
		for(const [team, entry] of Object.entries(game.results)){
			console.log(`Team ${team.split('#')[1]}\t\t${entry.score} points${entry.crashed ? '\t\tThis team crashed!':''}`);
		}

		const wants_download = (await inquirer.prompt([
			{
				name: 'response',
				type: 'confirm',
				message: 'Would you like to download your log for this game?'
			}
		])).response;
		if(!wants_download) return;
		const logs = (await apiRequest<getGameInfoEndpoint>('GET', `/tourneys/${tourneyID.split('#')[1]}/${game.ID.split('#')[1]}/${game.ID.split('#')[2]}` as '/tourneys/:tourney/:round/:game'));
		if(logs.status == 404) return catastrophicErr('Error while getting logs.');
		const gameJson = await (await fetch(logs.body.gameJsonLink)).text();
		let botLog : string | null = null;
		if(logs.body?.botLogLink) botLog = await (await fetch(logs.body.botLogLink)).text();
		const defaultPath = path.join(homedir(), '/.mm28/downloadedlogs/');
		const savePath : string = (await inquirer.prompt([{
			type: 'input',
			name: 'path',
			message: `Enter ${chalk.italic.blue('folder')} to save bot.log and game.json to:`,
			default: defaultPath
		}])).path;
		if(savePath == defaultPath) await mkdir(defaultPath, {recursive: true});
		await writeFile(path.join(savePath, `${game.ID}.json`), gameJson).catch(e => catastrophicErr(`Error while getting/saving game.json: ${e}`));
		if(botLog) await writeFile(path.join(savePath, `${game.ID}.log`), botLog).catch(e => catastrophicErr(`Error while getting/saving bot log: ${e}`));
		console.log(chalk.green('Logs saved!'));
	});

const logCommands = [viewTourneyCommand, getGameCommand];
export default logCommands;