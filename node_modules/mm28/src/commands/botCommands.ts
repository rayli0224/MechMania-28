import { Command } from 'commander';
import apiRequest from '../util/apiRequest.js';
import type {getBotEndpoint, getBotsEndpoint, uploadBotEndpoint} from '@mm28/shared/types/api/botApiTypes.js';
import chalk from 'chalk';
import {loggedIn, credentials} from '../util/auth.js';
import {mkdir, readFile, writeFile} from 'fs/promises';
import { catastrophicErr, fatalErr, notLoggedInErr } from '../util/messages.js';
import fetch from 'node-fetch';
import inquirer, { ListChoiceOptions } from 'inquirer';
import { homedir } from 'os';
import path from 'path';

const extensionToLang: Record<uploadBotEndpoint['requestBody']['lang'], string> = {
	'jar': 'java',
	'pyz': 'python'
};

// TODO : pls update readmes of starterpacks about uploading bot
const uploadCommand = new Command('upload').alias('push')
	.description('upload a new version of your bot')
	.argument('<bot-file-path>')
	.action(async (filepath) => {
		if(!loggedIn()) return notLoggedInErr();
		let file: Buffer;
		let lang: uploadBotEndpoint['requestBody']['lang'];
		switch (filepath.split('.').pop()) { // switch file extension
			case 'pyz':
				lang = 'pyz';
				break;
			case 'jar':
				lang = 'jar';
				break;
			case 'java':
			case 'class':
			case 'py':
			case 'py3':
				return fatalErr('Upload your .jar or .pyz file, not source or other compiler output.');
			default:
				return fatalErr('Unrecognized file extension. Upload a .jar or .pyz file.');
		}
		try {
			file = await readFile(filepath);
		} catch (e) {
			return fatalErr(`Error while reading file: ${e}`);
		}
		const response = await apiRequest<uploadBotEndpoint>('POST', `/teams/${credentials.name}/bots` as '/teams/:team/bots', {lang});
		fetch(response.body.presignedLink, {
			method: 'PUT',
			body: file,
			headers: {
				'Content-Length': file.length.toString()
			}
		})
			.catch((e) => catastrophicErr(`Error while uploading bot: ${e}`))
			.then(() => {console.log(chalk.green(`Successfully uploaded version ${response.body.version} to server.`));});
	});

const downloadCommand = new Command('download').alias('mybots')
	.description('view and download your past bot versions')
	.action(async () => {
		if(!loggedIn()) return notLoggedInErr();
		const botList = (await apiRequest<getBotsEndpoint>('GET', `/teams/${credentials.name}/bots` as '/teams/:team/bots')).body;
		if(botList.length == 0) return fatalErr('You have no uploaded bots!');
		botList.sort((a,b) => b.createdTime-a.createdTime);
		const botChoices : ListChoiceOptions[] = botList.map(({version, lang, createdTime}) => ({
			name: `#${version}\t${extensionToLang[lang]}\t${(new Date(createdTime)).toLocaleString(undefined, {
				month: 'numeric',
				day: 'numeric',
				hour: 'numeric',
				minute: 'numeric'
			})}`,
			short: `${version}.${lang}`,
			value: {
				version,
				lang
			}
		}));
		const ver : {version: number, lang: string} = (await inquirer.prompt([{
			type: 'list',
			loop: 'false',
			name: 'botVer',
			message: 'Pick a version to download:',
			choices: botChoices
		}])).botVer;
		const botBlob = await apiRequest<getBotEndpoint>('GET', `/teams/${credentials.name}/bots/${ver.version}` as '/teams/:team/bots/:version')
			.then(async ({body: link})=>{
				const response = await fetch(link);
				return response.body;
			}).catch(e => catastrophicErr(`Error while downloading bot: ${e}`));
		if(botBlob == null)	return catastrophicErr('Failed to get your bot: null body');
		const defaultPath = path.join(homedir(), '/.mm28/downloadedbots/');
		const savePath : string = (await inquirer.prompt([{
			type: 'input',
			name: 'path',
			message: `Enter ${chalk.italic.blue('folder')} to save bot to:`,
			default: defaultPath
		}])).path;
		if(savePath == defaultPath) await mkdir(defaultPath, {recursive: true});
		await writeFile(path.join(savePath, `${ver.version}.${ver.lang}`), botBlob).catch(e => catastrophicErr(`Error while getting/saving bot: ${e}`));
		console.log(chalk.green('Bot saved!'));
	});

const botCommands = [uploadCommand, downloadCommand];
export default botCommands;